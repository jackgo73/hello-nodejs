---
title: 应用安全加固的几个名词解释
date: 2017-12-06 09:14:59
categories: Bank
tags: bank
---

# 加壳

其实是利用特殊的算法，对EXE、DLL文件里的资源进行压缩、加密。类似WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。它们附加在原程序上通过Windows加载器载入内存后，先于原始程序执行，得到控制权，执行过程中对原始程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。加上外壳后，原始程序代码在磁盘文件中一般是以加密后的形式存在的，只在执行时在内存中还原，这样就可以比较有效地防止破解者对程序文件的非法修改，同时也可以防止程序被静态反编译。  

# 加花

实际上，把它按照“乱指令”来理解可能更贴切一些，它的真正英文名应该叫"thunkcode"吧(不确定，呵呵)。我们知道，汇编语 言其实就是机器指令的符号化，从某种程度上看，它只是更容易理解一点的机器指令而已。每一条汇编语句，在汇编时，都会根据cpu特定的指令符号表将汇编指 令翻译成二进制代码。而日常应用中，我们通过VC的IDE或其它如OD等反汇编、反编译软件也可以将一个二进制程序反汇编成汇编代码。机器的一般格式为： 指令＋数据。而反汇编的大致过程是：首先会确定指令开始的首地址，然后根据这个指令字判断是哪个汇编语句，然后再将后面的数据反汇编出来。由此，我们可以 看到，在这一步的反汇编过程中存在漏洞：如果有人故意将错误的机器指令放在了错误的位置，那反汇编时，就有可能连同后面的数据一起错误地反汇编出来，这 样，我们看到的就可能是一个错误的反汇编代码。这就是“花指令”，简而言之，花指令是利用了反汇编时单纯根据机器指令字来决定反汇编结果的漏洞。



# 脱壳

在一些计算机软件里有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然（但后来也出现了所谓的“壳中带籽”的壳）。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”了。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。 从功能上抽象，软件的壳和自然界中的壳相差无几。无非是保护、隐蔽壳内的东西。而从技术的角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密……。当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。 软件的壳分为加密壳、压缩壳、伪装壳、多层壳等类，目的都是为了隐藏程序真正的OEP（入口点，防止被破解）。



#  DEX文件函数级分离

DEX文件函数级分离（类抽取）保护技术采用基于类抽取加密的方式来实现的。针对DEX文件整体加壳（加密）技术能被内存dump这一弱点进行改进，能极大提高应用的安全性。其基本原理是利用java虚拟机执行方法的机制来实现。Java虚拟机在第一次执行某个类的某个方法前，才真正开始加载这个方法的代码。利用这个机制，DEX文件函数级分离（类抽取）保护技术将解密操作延迟到某个方法在确实要执行之前才对该方法进行解密，同时解密后的方法的代码在内存中是不连续存放的。

另外，如果某个方法没有被执行到，则该方法就不会被解密。第二代加固技术就是利用虚拟机执行方法的机制，在加固时对代码中的每个方法做单独加密，在运行时动态解密当前执行的方法。

DEX文件函数级分离（类抽取）保护技术的执行流程如下：

1. 打包时，将原APK中的所有方法的代码提取出来，单独加密到一个文件。
2. 运行时，加固引擎首先会动态修改当前进程Dalvik虚拟机，初始化动态解密的虚拟机适配层。
3. 当Dalvik虚拟机要执行某个方法时，加固引擎才解密该方法的代码，并将解密后的代码交给虚拟机执行引擎执行。



